# -*- coding: utf-8 -*-
"""ProjetoTransferLearning .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZngO3wkzDAjecAy_5vJjJBicQEtOA9jQ
"""

# Projeto de Transfer Learning em Python no Google Colab

# 1. Configuração do ambiente
import tensorflow as tf
from tensorflow.keras import layers, models
from tensorflow.keras.applications import MobileNetV2
from tensorflow.keras.preprocessing.image import ImageDataGenerator
import matplotlib.pyplot as plt
import tensorflow_datasets as tfds

# 2. Carregar o dataset Cats vs Dogs usando tensorflow_datasets
dataset_name = "cats_vs_dogs"
(dataset_train, dataset_val), dataset_info = tfds.load(
    dataset_name,
    split=["train[:80%]", "train[80%:]"],  # Dividir 80% para treino e 20% para validação
    as_supervised=True,
    with_info=True
)

# 3. Pré-processamento dos dados
batch_size = 32
img_height = 160
img_width = 160

def preprocess(image, label):
    image = tf.image.resize(image, (img_height, img_width))
    image = image / 255.0  # Normalizar
    return image, label

train_data = dataset_train.map(preprocess).shuffle(1000).batch(batch_size).prefetch(buffer_size=tf.data.AUTOTUNE)
val_data = dataset_val.map(preprocess).batch(batch_size).prefetch(buffer_size=tf.data.AUTOTUNE)

# 4. Construção do modelo com Transfer Learning
base_model = MobileNetV2(input_shape=(img_height, img_width, 3), include_top=False, weights='imagenet')
base_model.trainable = False  # Congelar os pesos do modelo pré-treinado

# Adicionar camadas personalizadas no topo
model = models.Sequential([
    base_model,
    layers.GlobalAveragePooling2D(),
    layers.Dense(1, activation='sigmoid')  # Saída binária (gato ou cachorro)
])

model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# 5. Treinar o modelo
epochs = 5
history = model.fit(
    train_data,
    validation_data=val_data,
    epochs=epochs
)

# 6. Avaliação e visualização dos resultados
acc = history.history['accuracy']
val_acc = history.history['val_accuracy']
loss = history.history['loss']
val_loss = history.history['val_loss']

epochs_range = range(epochs)

plt.figure(figsize=(8, 8))
plt.subplot(1, 2, 1)
plt.plot(epochs_range, acc, label='Acurácia de Treinamento')
plt.plot(epochs_range, val_acc, label='Acurácia de Validação')
plt.legend(loc='lower right')
plt.title('Acurácia')

plt.subplot(1, 2, 2)
plt.plot(epochs_range, loss, label='Loss de Treinamento')
plt.plot(epochs_range, val_loss, label='Loss de Validação')
plt.legend(loc='upper right')
plt.title('Loss')
plt.show()

# 7. Testar o modelo com novas imagens
def predict_image(image_path):
    from tensorflow.keras.utils import load_img, img_to_array
    image = load_img(image_path, target_size=(img_height, img_width))
    image_array = img_to_array(image) / 255.0  # Normalizar
    image_array = tf.expand_dims(image_array, axis=0)  # Adicionar dimensão de batch
    prediction = model.predict(image_array)
    if prediction[0] > 0.5:
        print("Cachorro")
    else:
        print("Gato")

